-- A. Añadir columna de seguro al Ledger para transparencia total
ALTER TABLE public.wallet_transactions
ADD COLUMN IF NOT EXISTS insurance_amount NUMERIC(12, 2) DEFAULT 0.00;

-- B. Actualizar la función Maestra
CREATE OR REPLACE FUNCTION public.fn_complete_order(
  p_buyer_id UUID,
  p_stripe_intent_id TEXT,
  p_product_ids UUID[],
  p_address_id UUID,
  p_total_amount NUMERIC,
  p_service_fee NUMERIC
)
RETURNS TABLE(success BOOLEAN, error_message TEXT) AS $$
DECLARE
  v_order_id UUID;
  v_addr_snapshot JSONB;
  v_prod RECORD;
  v_wallet_id UUID;
  v_net_payout NUMERIC;
  v_commission NUMERIC;
  v_insurance NUMERIC;
  v_new_pending_balance NUMERIC;
BEGIN
  -- 1. Idempotencia
  IF EXISTS (SELECT 1 FROM public.orders WHERE stripe_payment_intent_id = p_stripe_intent_id) THEN
    RETURN QUERY SELECT true, 'ALREADY_PROCESSED'::TEXT;
    RETURN;
  END IF;

  -- 2. Snapshot de dirección
  SELECT to_jsonb(a.*) INTO v_addr_snapshot FROM public.addresses a WHERE id = p_address_id;
  IF v_addr_snapshot IS NULL THEN
    RETURN QUERY SELECT false, 'ADDRESS_NOT_FOUND'::TEXT;
    RETURN;
  END IF;

  -- 3. Crear Orden
  INSERT INTO public.orders (buyer_id, stripe_payment_intent_id, total_amount, status, shipping_address, service_fee_amount)
  VALUES (p_buyer_id, p_stripe_intent_id, p_total_amount, 'paid', v_addr_snapshot, p_service_fee)
  RETURNING id INTO v_order_id;

  -- 4. Repartir dinero por cada producto
  FOR v_prod IN SELECT id, price, seller_id, shipping_cost FROM public.products WHERE id = ANY(p_product_ids) LOOP

    -- LÓGICA DE NEGOCIO SELENE
    v_commission := v_prod.price * 0.09;      -- 9% Comisión
    v_insurance  := v_prod.price * 0.012;     -- 1.2% Seguro
    v_net_payout := v_prod.price - v_commission - COALESCE(v_prod.shipping_cost, 0) - v_insurance;

    -- A. Guardar en Order Items (Auditoría de Venta)
    INSERT INTO public.order_items (
        order_id, product_id, seller_id, price_at_purchase,
        commission_amount, shipping_amount, insurance_amount, net_payout
    )
    VALUES (
        v_order_id, v_prod.id, v_prod.seller_id, v_prod.price,
        v_commission, COALESCE(v_prod.shipping_cost, 0), v_insurance, v_net_payout
    );

    -- B. Asegurar Wallet y actualizar saldo
    INSERT INTO public.wallets (user_id) VALUES (v_prod.seller_id)
    ON CONFLICT (user_id) DO UPDATE SET updated_at = now()
    RETURNING id INTO v_wallet_id;

    UPDATE public.wallets
    SET pending_balance = pending_balance + v_net_payout,
        updated_at = now()
    WHERE id = v_wallet_id
    RETURNING pending_balance INTO v_new_pending_balance;

    -- C. Crear registro en el Ledger con DESGLOSE TOTAL
    INSERT INTO public.wallet_transactions (
        wallet_id, order_id, amount, fee_deducted,
        shipping_cost, insurance_amount, net_amount, balance_after, type, description
    )
    VALUES (
        v_wallet_id, v_order_id, v_prod.price, v_commission,
        COALESCE(v_prod.shipping_cost, 0), v_insurance, v_net_payout,
        v_new_pending_balance, 'sale_proceeds', 'Venta Hardware: ' || v_prod.id
    );

    -- D. Marcar como vendido
    UPDATE public.products SET status = 'SOLD', updated_at = now() WHERE id = v_prod.id;

  END LOOP;

  RETURN QUERY SELECT true, NULL::TEXT;

EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT false, SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
